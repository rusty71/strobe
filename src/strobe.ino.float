//http://www.gammon.com.au/adc

//Band pass bessel filter order=1 alpha1=0.0041666666666667 alpha2=0.083333333333333 
//bandpass 40-800Hz & 9600 sps
//http://www.schwietering.com/jayduino/filtuino/index.php?characteristic=be&passmode=bp&order=1&usesr=usesr&sr=9600&frequencyLow=40&noteLow=&frequencyHigh=800&noteHigh=&pw=pw&calctype=float&run=Send
class  FilterBeBp1
{
	public:
		FilterBeBp1()
		{
			v[0]=0.0;
			v[1]=0.0;
		}
	private:
		float v[3];
	public:
		float step(float x) //class II 
		{
			v[0] = v[1];
			v[1] = v[2];
			v[2] = (2.215325404004425125e-1 * x)
				 + (-0.59493748153889325359 * v[0])
				 + (1.58378763569120906141 * v[1]);
			return 
				 (v[2] - v[0]);
		}
} filt;

//Band pass bessel filter order=1 alpha1=0.0041666666666667 alpha2=0.083333333333333 
class filter
{
	public:
		filter()
		{
			for(int i=0; i <= 2; i++)
				v[i]=0;
		}
	private:
		short v[3];
	public:
		short step(short x)
		{
			v[0] = v[1];
			v[1] = v[2];
			long tmp = ((((x * 1858350L) >>  3)	//= (   2.2153254040e-1 * x)
				+ ((v[0] * -1247674L) >> 1)	//+( -0.5949374815*v[0])
				+ (v[1] * 1660722L)	//+(  1.5837876357*v[1])
				)+524288) >> 20; // round and downshift fixed point /1048576

			v[2]= (short)tmp;
			return (short)((
				 (v[2] - v[0]))); // 2^
		}
} ;


volatile long long start, end;
volatile float result;

void setup ()
{
	Serial.begin (115200);
	//filter speed test, 51us
	//~ start = millis();
	//~ for(int j=0; j<10000; j++) {
		//~ result = filt.step(3.13);
	//~ }
	//~ end = millis();
	//~ Serial.println((int)(end - start));

	ADCSRA =  bit (ADEN);								//turn ADC on
	ADCSRA |= bit (ADPS0)|  bit (ADPS1) | bit (ADPS2);	// Prescaler of 128(9600 Hz), //64 (1 << ADPS2) | (1 << ADPS1);
	ADMUX  =  bit (REFS0)| (0 & 0x07);					//AVcc and select input port
	ADCSRA |= bit (ADSC) | bit (ADIE);
	ADCSRA |= bit (ADATE);
	pinMode(9,OUTPUT);
	pinMode(8,OUTPUT);
	digitalWrite(9, HIGH);
	digitalWrite(8, LOW);
}

volatile int min=1024, max=0, adc;

volatile float step, step_1 = 0.0;
volatile bool was_negative = true; //Zero crossing from negative to positive
volatile bool cross = false;
#define THRESHOLD  (1.4)
volatile long count_1 = 0, count = 0;

ISR (ADC_vect)	//20us without filter, 80us with
{
	digitalWrite(8, HIGH);
	adc = ADC;
    //~ Serial.println(adc);
	//filter input sample. about 51us !
	step = filt.step((float)adc-511);
	//detect zero crossing
	if(was_negative) {	//last valuation was negative
		if((step - THRESHOLD) > 0.0) { //negative to positive
			was_negative = false;
			cross = true;
		}
	}
	else {
		if((step + THRESHOLD) < 0.0) {
			was_negative = true;
		}
	}
	count++;
	digitalWrite(8, LOW);
}

int i;

void loop ()
{
	while(!cross)
		;
	cross = false;
	digitalWrite(9, HIGH);
	delay(1);
	digitalWrite(9, LOW);
    //~ for(i = 0; i < 40+((int)(step)); i++)
        //~ Serial.print(" ");
    //~ Serial.println("*");
	Serial.println(count-count_1);
	count_1 = count;

}

