#include "TaskScheduler.h"
//http://www.gammon.com.au/adc

//Band pass bessel filter order=1 alpha1=0.0041666666666667 alpha2=0.083333333333333 
//http://www.schwietering.com/jayduino/filtuino/index.php?characteristic=be&passmode=bp&order=1&usesr=usesr&sr=9600&frequencyLow=40&noteLow=&frequencyHigh=800&noteHigh=&pw=pw&calctype=long&bitres=16&run=Send
class filter
{
	public:
		filter()
		{
			for(int i=0; i <= 2; i++)
				v[i]=0;
		}
	private:
		short v[3];
	public:
		short step(short x)
		{
			v[0] = v[1];
			v[1] = v[2];
			long tmp = ((((x *  29037L) >>  3)	//= (   2.2153254040e-1 * x)
				+ ((v[0] * -19495L) >> 1)	//+( -0.5949374815*v[0])
				+ (v[1] * 25949L)	//+(  1.5837876357*v[1])
				)+8192) >> 14; // round and downshift fixed point /16384

			v[2]= (short)tmp;
			return (short)((
				 (v[2] - v[0]))); // 2^
		}
} filt;




//volatile for ISR communication
volatile int8_t cross = false;
volatile long count_last = 0, count = 0, lcount = 0;
#define THRESHOLD  (4)	//TODO: make dynamic

ISR (ADC_vect)
{
static bool was_negative = true; //Zero crossing from negative to positive
static short step, phase = 0;


	digitalWrite(8, HIGH);	//for measuring timing
	step = filt.step((short)ADC);	//23us !
	//detect zero crossing
	if(was_negative) {	//last valuation was negative
		if((step - THRESHOLD) > 0) { //negative to positive
			was_negative = false;
			count_last = lcount;
			lcount = 0;
			if(phase++ > 2) {
				phase = 0;
				count = 0;
			}
			cross++;	//doorbel
		}
	}
	else {
		if((step + THRESHOLD) < 0) {
			was_negative = true;
		}
	}
	count++;
	lcount++;  //FIXME
	digitalWrite(8, LOW);
}

Scheduler runner;
void t1Callback();	//proto
Task t1(100, TASK_FOREVER, &t1Callback);
void t2Callback();	//proto
Task t2(600, TASK_FOREVER, &t2Callback);
void blinkCallback();	//proto
Task blink(5, 2, &blinkCallback);

void setup ()
{
	Serial.begin (115200);
	Serial.println("Start");
	//filter speed test, float=51us, int=23
	//~ start = millis();
	//~ for(int j=0; j<10000; j++) {
		//~ result = filt.step(3.13);
	//~ }
	//~ end = millis();
	//~ Serial.println((int)(end - start));

	ADCSRA =  bit (ADEN);								//turn ADC on
	ADCSRA |= bit (ADPS0)|  bit (ADPS1) | bit (ADPS2);	// Prescaler of 128(9600 Hz), //64 (1 << ADPS2) | (1 << ADPS1);
	ADMUX  =  bit (REFS0)| (0 & 0x07);					//AVcc and select input port
	ADCSRA |= bit (ADSC) | bit (ADIE);
	ADCSRA |= bit (ADATE);
	pinMode(9,OUTPUT);
	TCCR1B = TCCR1B & B11111000 | B00000001;    // set timer 1 divisor to     1 for PWM frequency of 31372.55 Hz
	pinMode(8,OUTPUT);
	//digitalWrite(9, HIGH);
	digitalWrite(8, LOW);

	//setup task
	runner.init();
	runner.addTask(t1);
	t1.enable();
	//~ runner.addTask(t2);
	//~ t2.enable();
	runner.addTask(blink);
	blink.enable();
}

typedef struct {
	long angle;
	int next;
	int period;
	unsigned long on;
} ANGLE;

ANGLE angles[] = { {10, 0, 1, 0}, {10, 0, 1, 0} };

#define FRAC_SHIFT 15
//integer degrees 0-359
void setangle(int slot, long angle) {
	angles[slot].angle = (angle << FRAC_SHIFT)/120;	//expensive division. test speed.
}

//returns tick for s give angle, given current speed
//called every revolution, must be fast!
int getangle(int slot, int last_ticks) {
	return (angles[slot].angle * last_ticks)>>FRAC_SHIFT;
}

//called twice
void blinkCallback() {
	static bool toggle = true;
	if(toggle)
		analogWrite(9, 255);	//ON
	else
		analogWrite(9, 0);		//OFF
	Serial.print(".");
}


//called every 200ms
void t1Callback() {
	static int angle = 0;
	
	angle = angle + 7;
	if(angle > 360)
		angle = 0;
	setangle(0, angle);	
}

//called every 300ms
void t2Callback() {
	static int angle = 360;
	
	angle = angle - 3;
	if(angle < 0)
		angle = 360;
	setangle(1, angle);	
}

#define NR_ANGLES 1

void loop ()
{
	while(!cross) {
		for(int angle_i = 0; angle_i < NR_ANGLES; angle_i++) {
			if((angles[angle_i].on==0) && (count >= angles[angle_i].next)) {
				//~ Serial.print("1");
				//~ blink.restart();
				analogWrite(9, 255);	//ON
				angles[angle_i].on = millis();
				angles[angle_i].next = 30000;	//TODO.
			}
			else if(angles[angle_i].on) {
				if( (angles[angle_i].on + angles[angle_i].period) < millis() ) {
					//~ Serial.print("0");
					analogWrite(9, 0);	//OFF
					angles[angle_i].on = 0;
				}
			}
			else {
				//~ Serial.print(count);
				//~ Serial.print(":");
				//~ Serial.println(angles[angle_i].next);
			}
			
		}
	}
	cross = false;

	//update angles for next iteration
	for(int angle_i = 0; angle_i < NR_ANGLES; angle_i++) {
		angles[angle_i].next = getangle(angle_i, count_last);	//calculate next fire moment
	}
	//schedule tasks	//SPEED!
	runner.execute();

	Serial.print(count_last);
	Serial.print(":");
	Serial.println(count);
	//~ Serial.print(":");
	//~ Serial.println(angles[1].next);
}

